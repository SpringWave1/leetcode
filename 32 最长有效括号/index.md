# 题目
给定一个只包含 '('')'的字符串，找出最长的包含有效括号的子串的长度
# 思路
保存一个当前长度 length 和一个最大长度 max_length
1. 动态规划
   1. 假设 dp[i] 代表以 ')' 结尾的最长有效括号的长度
   2. 两种情况,第一种 '(' 跟着 ')'，此时 dp[i] = dp[i - 2] + 2 （左边的最长括号带上新的两个值）
   3. 第二种 ')' 跟着 ')' 
      1. 此时需要找到第一个 '(', i - 1 的长度为 dp[i-1]，那么第一个为 i - dp[i-1] - 1
      2. dp[i] = dp[i-1](中间括号的值) + dp[i - dp[i-1] - 2] 左边括号的值 + 2
      3. 如果不存在 '(' , 则 1 为 -1，所以 >= 0
   4. 两种情况实际上可以合并 
      1. 左侧为 '(': dp[i - dp[i-1] - 1] = '('
      2. 左侧大于 0: i - dp[i-1] - 1 >=0
      3. dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2
   5. 时间复杂度 n 空间复杂度 n

2. 栈
   1. -1 先入栈
   2. 只有两种情况会入栈 '(' 或者边界 ')' 
   3. 碰到 ')' 后，pop，如果栈中有值，说明还未到达边界，更新 max_length 为 i - 栈顶 idx
   4. 如果栈无值，则更新边界

3. 正向逆向结合
   1. 直接记录括号长度
   2. 左右相等则 length * 2
   3. 但是要正向逆向操作
      1. 正向，右 > 左则置0
      2. 逆向 左 > 右则置0
   4. 这个 code 略长


