# 前言
这类题目实在太过相像，因此直接放一块


# 76
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。
>
示例：
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"

# 438
给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 思路
76
- 用 mem dict 记录 t 中字符出现频次，同时记录 t 的长度 dis
- 初始化最长数组 0, len(s)
- 双指针，右侧递归，每遇到一个字符，mem[c] - 1，如果 c 在 t 中，dis -= 1
- 当 dis = 0, 则当前字符串已经包含子串,开始缩小左侧范围
- 结束后更新最长数组 minleft, minright = left, right
- 左侧往右加1，同时 mem + 1, dis + 1

438
- 和 76 唯一的区别是，该字符串的长度必须和子串相等
- which is right - left + 1 = com_dis