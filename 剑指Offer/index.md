# 先把思路都看一遍再说
## Offer 09
两个栈实现队列
- 一个 stack 作为 queue 
- 一个 stack 作为辅助。每次有新值加入就全部 push 到另外一个 stack 再加入。
## Offer 10- 1 and 2
两道递归题
## 矩阵中路径
看起来很难，先过
## 机器人的运动范围
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
### 思路
先写一个判断格子是否符合的函数
 - 最简单的办法就遍历，然后看每一个格子是否符合。
 - 递归就是 1 + 四个角落，然后带一个 visited 存一下是否访问过
 - 终点就是边界条件，访问过，以及小于答案要求
## 剪绳子
3 作为因数最优。
## 二进制有几个1
整数 - 1 & 原整数会把最右边的一个 1 变成 0，然后可以继续 count
## POW 快速幂
所有的 POW 都能拆成二进制形式。例如 9 可以拆成 1 * 1 + 0 * 2 + 0 * 4 + 1 * 8
- 乘的第一位是幂的二进制数
- 乘的第二位是一个不停迭代的值
- 换成 x 就是 x + x^2 + x^4 ...
  
思路：
- & 1 判断当前位是否有值，有值则乘到 res 里，>> 1
- 每一轮更新乘值（上一轮的平方）
## 正则表达
真的恶心，下次再说
## 调整数组
双指针法
## 倒数节点
双指针法
## 反转链表
递归就完事了
## 两个排序链表
也算双指针吧，一个指针指着一个。然后往后一个个比就完事了。
## 树的子结构
思路：和 isSameTree 一样
#### is sameTree
- 结束条件：在叶的 None 结束 或者值不一样
  - 传入的node只要有一个为 None，判断两个是否都为 None，返回 True
- 值不一样返回 False
- return 左右比较的 &
子结构和前面那个不同的是。结束条件
- 如果子树被遍历完了，则返回 True
- 如果父亲树空了，则返回 False
# 题目
找出数组中重复的数字
> 
```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

# 